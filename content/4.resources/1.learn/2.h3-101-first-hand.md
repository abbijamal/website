---
title: Build your first H3 app
description: Get started with H3 by building a simple app.
resources:
  - # add a link to the examples repo
  - # add a link to the documentation
---


H3 is a minimal http framework for high performance and portability.

During this tutorial, we will create a simple app to get a wide overview of H3 capabilities. This app will serve an HTML file populated with data. There will be some forms to add and remove data. At the end, we will see how to add an API endpoint to get the data in JSON format.

> [!NOTE]
> Deep dive into H3 through [the dedicated documentation](https://h3.unjs.io).

## Prerequisites

To follow this tutorial, we need to have [Node.js](https://nodejs.org/en/) installed on our machine with [npm](https://www.npmjs.com/). We also need to have a basic knowledge of JavaScript.

> [!NOTE]
> Despite H3 is written in TypeScript, you don't need to know TypeScript to use it.

## Create a New Project

First, let's create a new npm project:

```bash
mkdir my-h3-app
cd my-h3-app
npm init -y
```

Then, install H3:

```bash
npm install h3
```

And that's it! We are ready to start coding.

## Create the App

To create our first H3 app, we need to create an `app.ts` file at the root of our project. Inside, we will create a new app by importing the `createApp` function from H3 and calling it:

```ts [app.ts]
import { createApp } from 'h3';

export const app = createApp();
```

:read-more{to="https://h3.unjs.io/concepts/app" title="App"}

Do not forget the `export` keyword, it's important for the listener.

## Add a Listener

Speaking of listener, our app is not able to respond to any request yet. To do so, we need to add a listener. A listener is used to listen an HTTP event, transfert it to our app and send back the response.

For our tutorial, we will use [unjs/listhen](https://listhen.unjs.io).

In the `package.json` file, add a script named `start`:

```json [package.json]
{
  "scripts": {
    "start": "npx --yes listhen -w ./app.ts"
  }
}
```

This script will start a server listening on port `3000` using our app and watching for changes.

We can now run the command `npm start` to start our server.

## Create a Router

Now that our app is ready to accept HTTP requests, we need to create a router to handle them. The purpose of the router is to match the request to the right handler.

With H3, we've just to use the function `createRouter` and add it to our app:

```ts [app.ts]
import { createApp, createRouter } from 'h3';

export const app = createApp();

const router = createRouter();

app.use(router);
```

The `app.use(router)`{lang="ts"} is necessary to add the router to our app.

:read-more{to="https://h3.unjs.io/concepts/router" title="Router"}

## Add our First Handler

We have an app and a router. The only thing missing is the handlers. A handler is a function that will be called when a request matches the route.

> [!NOTE]
> We may refer to controllers in other frameworks.

To add a handler, we can use any of the HTTP methods available on the router. For our tutorial, we will use the `get` method to handle the `GET` requests.

```ts [app.ts]
// ...

const router = createRouter();

router.get('/', () => {
  return 'Hello World!';
});
```

In the code above, we added a handler for the `/` route. This handler will send the string `Hello World!` to the client with a simple `return`{lang="ts"}.

:read-more{to="https://h3.unjs.io/concepts/event-handlers" title="Event Handlers"}

## Create a Fake Database

For our app, we will return an HTML page populated with some data. This part will not be explained in details since it's not the purpose of this tutorial.

To create our fake database (a JavaScript array) with some getters and setters, we need a file named `database.ts`:

```ts [database.ts]
import { Book } from "./types";

/**
 * This is a fake database since it's just an array of objects.
 *
 * For this example, it's sufficient but do not use this in production.
 */
const database: Book[] = [{
  title: "Anna Karenina",
  price: 42,
}, {
  title: "Madame Bovary",
  price: 15,
}, {
  title: "War and Peace",
  price: 36,
}, {
  title: "The Great Gatsby",
  price: 87,
}, {
  title: "Lolita",
  price: 23,
}
];

export function getBooks(): Book[] {
  return database;
}

export function addBook(book: Book) {
  database.push(book);
}

export function removeBook(title: string) {
  const item = database.find((item) => item.title === title);

  if (!item) {
    return
  }

  const index = database.indexOf(item);

  if (index > -1) {
    database.splice(index, 1);
  }
}
```

Add some types on a file named `types.ts`:

```ts [types.ts]
export interface Book {
  title: string
  price: number
}
```

> [!IMPORTANT]
> This is a fake database since it's just an array of objects. For this example, it's sufficient but **do not use this in production**.

## Our First HTML Page

For this first route, we will get the books from the database and render them in an HTML page. For each book, we will add a for to remove it from the database. Under the list, we will add a form to add a new book.

For the style, we will use [Pico CSS](https://picocss.com/).


```ts [app.ts]
// ...

const router = createRouter()

router.get('/', defineEventHandler(() => {
  const books = getBooks()

  return /* html */`
    <html>
      <head>
        <title>Books</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
      </head>
      <body>
        <main class="container">
          <section>
        <h1>Books</h1>
        <ul>
          ${books.map((book) => /* html */`
          <li>
          ${book.title} - ${book.price}
          <form action="/remove" method="post">
            <input type="hidden" name="title" value="${book.title}" />
            <button type="submit">Remove</button>
          </form>
        </li>
          `).join('')}
        </ul>
        </section>
        <section>
          <h2>Add a book</h2>
          <form action="/add" method="post">
            <label for="title">Title</label>
            <input type="text" name="title" id="title" />
            <label for="price">Price</label>
            <input type="number" name="price" id="price" />
            <button type="submit">Add</button>
          </form>
        </section>
      </main>
      </body>
    </html>
  `
}))
```

> [!NOTE]
> The comment `/* html */` is used by [a VS Code extension](https://marketplace.visualstudio.com/items?itemName=bierner.comment-tagged-templates) to provide syntax highlighting.

Open a browser and go to `http://localhost:3000` to see the result.

:read-more{to="https://h3.unjs.io/concepts/event-handlers#responses-types" title="Responses Types"}

## Interact with the Database

In our HTML page, we have two forms. One to add a book and one to remove a book. We need to add two new routes to handle them.

### Add a Book

To add a book, we need to handle a `POST` request on the `/add` route. We will also validate the data sent by the client using [Zod](https://zod.dev/) and we need to install it:

```bash
npm install zod
```

> [!NOTE]
> Zod is a TypeScript-first schema declaration and validation library. It's not mandatory to use it with H3 but it's a good practice to validate the data since it's runtime agnostic.

Then, we can add the route:

```ts [app.ts]
import { z } from 'zod'
// ...
const router = createRouter()

router.post('/add', defineEventHandler(async (event) => {
  const body = await readValidatedBody(event, z.object({
    title: z.string(),
    price: z.number({ coerce: true }).int().nonnegative(),
  }).parse)

  addBook(body)

  const referer = getHeader(event, 'referer') ?? '/'
  return sendRedirect(event, referer)
}))
```

There is two important things to notice in this code.

First, we use the `readValidatedBody` function to read the body of the request and validate it. It's important to validate the data sent by the client to avoid any security issue.

Second, we use the `sendRedirect` function to redirect the client to the previous page. We use the `referer` header to get the previous page. If the header is not present, we redirect to the root page.

> [!NOTE]
> We should think to redirect to `/` but using the referer is a better practice if we change the root page.

:read-more{to="https://h3.unjs.io/guides/validate-data" title="Validate Data"}

### Remove a Book

Nothing new here, we will handle a `POST` request on the `/remove` route:

```ts [app.ts]
// ...
const router = createRouter()

router.post('/remove', defineEventHandler(async (event) => {
  const body = await readValidatedBody(event, z.object({
    title: z.string(),
  }).parse)

  removeBook(body.title)

  const referer = getHeader(event, 'referer') ?? '/'
  return sendRedirect(event, referer)
}))
```

Same as before, we use the `readValidatedBody` function to read the body of the request and validate it. Then, we use the `sendRedirect` function to redirect the client to the previous page.

:read-more{to="https://h3.unjs.io/guides/validate-data" title="Validate Data"}

## Add an API Endpoint

We would need to add an API endpoint for external services. For this example, we will create another router dedicated to the API.

```ts [app.ts]
// ...
const apiRouter = createRouter()
```

Like any router, we will add an handler for the `/books` route:

```ts [app.ts]
// ...
apiRouter.get('/books', defineEventHandler(() => {
  const books = getBooks()

  return books
}))
```

Then, we will bind this second router to the first one using a base path:

```ts [app.ts]
// ...
router.use('/api/**', useBase('/api', apiRouter.handler))
```

This means that every `/api/` route will be handled by the `apiRouter` and this second router will be called with the path without the `/api` prefix to find the right handler.

:read-more{to="https://h3.unjs.io/concepts/router#nested-routers" title="Nested Routers"}

## Conclusion

And voil√†! We now have our first H3 app!

During this course, we saw how to create a H3 app, use a listener with it, create a router, add handlers, validate data. But there is a lot more to discover about H3 on [the dedicated documentation](https://h3.unjs.io).

Then, do not hesitate to take a look at [Nitro](https://nitro.unjs.io) to create more advanced web servers that run everywhere.
